/**
 * INPUT NORMALIZATION LAYER
 * Converts PDF/text into clean line array
 * Removes header/footer junk, preserves row integrity
 * NO HEURISTICS - strict validation only
 */

export type SourceType = 'PDF' | 'TEXT' | 'PASTE';

export interface NormalizedInput {
  lines: string[];
  sourceType: SourceType;
  confidence: number;
  metadata: {
    originalLineCount: number;
    cleanedLineCount: number;
    removedLines: number;
    warnings: string[];
  };
}

/**
 * Header/footer patterns to remove
 */
const JUNK_PATTERNS = [
  /^page \d+ of \d+$/i,
  /^printed on:/i,
  /^generated by:/i,
  /^xactimate version/i,
  /^copyright/i,
  /^confidential/i,
  /^estimate #/i,
  /^claim #/i,
  /^insured:/i,
  /^carrier:/i,
  /^adjuster:/i,
  /^date:/i,
  /^project:/i,
  /^\s*$/,  // Empty lines
  /^-{3,}$/,  // Separator lines
  /^={3,}$/,  // Separator lines
  /^_{3,}$/   // Separator lines
];

/**
 * Check if line is header/footer junk
 */
function isJunkLine(line: string): boolean {
  const trimmed = line.trim();
  
  if (trimmed.length === 0) return true;
  if (trimmed.length < 5) return true;
  
  for (const pattern of JUNK_PATTERNS) {
    if (pattern.test(trimmed)) {
      return true;
    }
  }
  
  return false;
}

/**
 * Check if line is a table header
 */
function isTableHeader(line: string): boolean {
  const lower = line.toLowerCase();
  
  // Must contain at least 2 of these keywords
  const headerKeywords = ['description', 'quantity', 'unit', 'rcv', 'acv', 'price', 'total', 'amount'];
  const matchCount = headerKeywords.filter(keyword => lower.includes(keyword)).length;
  
  return matchCount >= 2;
}

/**
 * Check if line contains estimate data
 */
function isEstimateLine(line: string): boolean {
  const trimmed = line.trim();
  
  // Must have minimum length
  if (trimmed.length < 15) return false;
  
  // Must contain at least one number
  if (!/\d/.test(trimmed)) return false;
  
  // Must contain at least one letter (description)
  if (!/[a-zA-Z]/.test(trimmed)) return false;
  
  // Should not be a total line
  if (/^total/i.test(trimmed)) return false;
  if (/^subtotal/i.test(trimmed)) return false;
  if (/^grand total/i.test(trimmed)) return false;
  
  return true;
}

/**
 * Normalize text input
 */
export function normalizeInput(
  input: string,
  sourceType: SourceType = 'TEXT'
): NormalizedInput {
  const warnings: string[] = [];
  
  // Split into lines
  const rawLines = input.split(/\r?\n/);
  const originalLineCount = rawLines.length;
  
  // Remove junk lines
  const cleanedLines: string[] = [];
  let headerFound = false;
  
  for (const line of rawLines) {
    // Skip junk
    if (isJunkLine(line)) {
      continue;
    }
    
    // Detect and skip table headers (but mark that we found one)
    if (isTableHeader(line)) {
      headerFound = true;
      continue;
    }
    
    // Only keep estimate lines
    if (isEstimateLine(line)) {
      cleanedLines.push(line);
    }
  }
  
  // Calculate confidence
  let confidence = 0;
  
  if (cleanedLines.length === 0) {
    confidence = 0;
    warnings.push('No valid estimate lines detected');
  } else {
    // Base confidence on line quality
    const ratio = cleanedLines.length / Math.max(originalLineCount, 1);
    
    // Good ratio: 0.2 - 0.8 (too low = mostly junk, too high = missing headers)
    if (ratio >= 0.2 && ratio <= 0.8) {
      confidence = 0.9;
    } else if (ratio > 0.8) {
      confidence = 0.6;
      warnings.push('High line ratio - possible missing headers or malformed input');
    } else {
      confidence = 0.5;
      warnings.push('Low line ratio - possible excessive junk or poor extraction');
    }
    
    // Boost confidence if header was found
    if (headerFound) {
      confidence = Math.min(1.0, confidence + 0.1);
    }
    
    // Check for minimum line count
    if (cleanedLines.length < 3) {
      confidence = 0.4;
      warnings.push('Very few lines detected - possible incomplete estimate');
    }
  }
  
  return {
    lines: cleanedLines,
    sourceType,
    confidence,
    metadata: {
      originalLineCount,
      cleanedLineCount: cleanedLines.length,
      removedLines: originalLineCount - cleanedLines.length,
      warnings
    }
  };
}

/**
 * Validate normalized input
 */
export function validateNormalizedInput(input: NormalizedInput): boolean {
  // Reject if confidence too low
  if (input.confidence < 0.7) {
    throw new Error(
      `Input normalization confidence too low: ${input.confidence.toFixed(2)} (minimum 0.70). ` +
      `Warnings: ${input.metadata.warnings.join(', ')}`
    );
  }
  
  // Reject if too few lines
  if (input.lines.length < 3) {
    throw new Error(
      `Insufficient estimate lines: ${input.lines.length} (minimum 3 required)`
    );
  }
  
  return true;
}
